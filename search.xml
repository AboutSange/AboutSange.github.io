<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python知识点之闭包]]></title>
    <url>%2F2019%2F02%2F27%2FPython%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B9%8B%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[目录1. 作用域（LEGB）2. 闭包是什么？3. 为什么要用闭包？4. 为什么通过闭包能实现在函数之外访问函数的局部变量？ 正文作用域（LEGB）LEGB 代表名字查找顺序: locals -&gt; enclosing function -&gt; globals -&gt; __builtins__ locals 是函数内的名字空间，包括局部变量和形参 enclosing 外部嵌套函数的名字空间（闭包中常见） globals 全局变量，函数定义所在模块的名字空间 builtins 内置模块的名字空间 闭包是什么？闭包（Closure），又称函数闭包，是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。 为什么要用闭包？（1）闭包避免使用全局变量（2）闭包允许将函数与其所操作的某些数据（环境）关联起来（3）装饰器场景 为什么通过闭包能实现在函数之外访问函数的局部变量？def adder(x): def wrapper(y): return x + y return wrapperadder5 = adder(5)adder5(10) # 输出 15adder5(6) # 输出 11 所有函数都有一个 closure属性，如果这个函数是一个闭包的话，那么它返回的是一个由 cell 对象 组成的元组对象。cell 对象的cell_contents 属性就是闭包中的自由变量。 &gt;&gt;&gt; adder.__closure__&gt;&gt;&gt; adder5.__closure__(&lt;cell at 0x103075910: int object at 0x7fd251604518&gt;,)&gt;&gt;&gt; adder5.__closure__[0].cell_contents5 这解释了为什么局部变量脱离函数之后，还可以在函数之外被访问的原因的，因为它存储在了闭包的 cell_contents中了。 参考文章 一步一步教你认识Python闭包 - FooFish-Python之禅]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python知识点之装饰器]]></title>
    <url>%2F2019%2F02%2F27%2FPython%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B9%8B%E8%A3%85%E9%A5%B0%E5%99%A8%2F</url>
    <content type="text"><![CDATA[目录1. 装饰器是什么？2. 为什么Python要引入装饰器？3. 装饰器有利于解决哪些问题？4. 装饰器有什么知识点？ 4.1 @是什么？ 4.2 带参数的装饰器实现 4.3 用类实现装饰器 4.4 多个装饰器执行顺序 4.5 functools.wraps有什么用？5. 装饰器的原理是什么？ 正文装饰器是什么？（1）在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）；（2）本质上是一个返回函数的高阶函数（闭包）； 为什么Python要引入装饰器？（1）便于开发，便于代码复用；（2）它可以让其他函数在不需要做任何代码变动的前提下增加额外功能； 装饰器有利于解决哪些问题？有利于解决有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景 装饰器常见问题@是什么？@是语法糖，用以精简代码 带参数的装饰器实现import loggingdef use_logging(level): def decorator(func): def wrapper(*args, **kw): if level == 'warn': logging.warn('%s is running' % func.__name__) return func(*args, **kw) return wrapper return decorator@use_logging(level="warn")def foo(name="foo"): print 'i am %s' % name foo() 装饰器等效于foo = use_logging(level="warn")(foo)foo() 运行结果如下：WARNING:root:foo is runningi am foo 用类实现装饰器 主要是依靠类内部的__call__方法 class Foo(object): def __init__(self, func): self._func = func def __call__(self, *args, **kw): print 'class decorator running' self._func(*args, **kw) print 'class decorator ending'@Foodef bar(x): print 'bar &#123;0&#125;'.format(x) bar(1) 装饰器等效于bar = Foo(bar)bar(1) 运行结果如下：class decorator runningbar 1class decorator ending 多个装饰器执行顺序def decorator_a(func): print 'Get in decorator_a' def inner_a(*args, **kwargs): print 'Get in inner_a' return func(*args, **kwargs) return inner_adef decorator_b(func): print 'Get in decorator_b' def inner_b(*args, **kwargs): print 'Get in inner_b' return func(*args, **kwargs) return inner_b@decorator_b@decorator_adef f(x): print 'Get in f' return x * 2f(1) 装饰器等效于f = decorator_b(decorator_a(f))f(1) 运行结果如下（定义时执行顺序为由内到外，调用时执行顺序为由外到内）：Get in decorator_aGet in decorator_bGet in inner_bGet in inner_aGet in f functools.wraps有什么用？ functools.wraps能把被调用函数的元信息（__module__, __name__, __qualname__, __doc__, __annotations__）赋值给装饰器返回的函数对象 import functoolsdef make_bold(func): @functools.wraps(func) def wrapper(*args, **kwargs): return '&lt;b&gt;&#123;0&#125;&lt;/b&gt;'.format(func(*args, **kwargs)) return wrapper 装饰器的原理是什么？装饰器本质是一个返回函数的高阶函数。装饰器放在一个函数头上相当于将这个函数对象当成参数传给装饰函数去执行，在定义时就执行（没调用也会执行） 参考文章 如何理解Python装饰器？ - python教程的回答 - 知乎 装饰器-廖雪峰的官方网站 如何理解Python装饰器？ - 刘志军的回答 - 知乎 Python 装饰器执行顺序迷思 - Python提高班 - SegmentFault 思否 简单地理解Python的装饰器 —— 0xFEE1C001]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F01%2F01%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new "My New Post" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>网站搭建</category>
      </categories>
      <tags>
        <tag>网站搭建</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
