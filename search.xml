<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python知识点之装饰器]]></title>
    <url>%2F2019%2F02%2F27%2FPython%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B9%8B%E8%A3%85%E9%A5%B0%E5%99%A8%2F</url>
    <content type="text"><![CDATA[目录1. 装饰器是什么？2. 为什么Python要引入装饰器？3. 装饰器有利于解决哪些问题？4. 装饰器有什么知识点？ 4.1 @是什么？ 4.2 带参数的装饰器实现 4.3 用类实现装饰器 4.4 多个装饰器执行顺序 4.5 functools.wraps有什么用？5. 装饰器的原理是什么？ 正文装饰器是什么？（1）在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）；（2）本质上是一个返回函数的高阶函数（闭包）； 为什么Python要引入装饰器？（1）便于开发，便于代码复用；（2）它可以让其他函数在不需要做任何代码变动的前提下增加额外功能； 装饰器有利于解决哪些问题？有利于解决有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景``` ### 装饰器常见问题#### @是什么？ @是语法糖，用以精简代码#### 带参数的装饰器实现```pythonimport loggingdef use_logging(level): def decorator(func): def wrapper(*args, **kw): if level == &apos;warn&apos;: logging.warn(&apos;%s is running&apos; % func.__name__) return func(*args, **kw) return wrapper return decorator@use_logging(level=&quot;warn&quot;)def foo(name=&quot;foo&quot;): print &apos;i am %s&apos; % name foo() 装饰器等效于foo = use_logging(level="warn")(foo)foo() 运行结果如下：WARNING:root:foo is runningi am foo 用类实现装饰器 主要是依靠类内部的__call__方法 class Foo(object): def __init__(self, func): self._func = func def __call__(self, *args, **kw): print 'class decorator running' self._func(*args, **kw) print 'class decorator ending'@Foodef bar(x): print 'bar &#123;0&#125;'.format(x) bar(1) 装饰器等效于bar = Foo(bar)bar(1) 运行结果如下：class decorator runningbar 1class decorator ending 多个装饰器执行顺序def decorator_a(func): print 'Get in decorator_a' def inner_a(*args, **kwargs): print 'Get in inner_a' return func(*args, **kwargs) return inner_adef decorator_b(func): print 'Get in decorator_b' def inner_b(*args, **kwargs): print 'Get in inner_b' return func(*args, **kwargs) return inner_b@decorator_b@decorator_adef f(x): print 'Get in f' return x * 2f(1) 装饰器等效于f = decorator_b(decorator_a(f))f(1) 运行结果如下（定义时执行顺序为由内到外，调用时执行顺序为由外到内）：Get in decorator_aGet in decorator_bGet in inner_bGet in inner_aGet in f functools.wraps有什么用？ functools.wraps能把被调用函数的元信息（__module__, __name__, __qualname__, __doc__, __annotations__）赋值给装饰器返回的函数对象 import functoolsdef make_bold(func): @functools.wraps(func) def wrapper(*args, **kwargs): return '&lt;b&gt;&#123;0&#125;&lt;/b&gt;'.format(func(*args, **kwargs)) return wrapper 装饰器的原理是什么？装饰器本质是一个返回函数的高阶函数。装饰器放在一个函数头上相当于将这个函数对象当成参数传给装饰函数去执行，在定义时就执行（没调用也会执行） 参考文章 如何理解Python装饰器？ - python教程的回答 - 知乎 装饰器-廖雪峰的官方网站 如何理解Python装饰器？ - 刘志军的回答 - 知乎 Python 装饰器执行顺序迷思 - Python提高班 - SegmentFault 思否 简单地理解Python的装饰器 —— 0xFEE1C001]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F02%2F27%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new "My New Post" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>网站搭建</category>
      </categories>
      <tags>
        <tag>网站搭建</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
